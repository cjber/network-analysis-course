---
title: "Introduction to (Social) Network Analysis in R"
author: "Dr Griffith Rees"
date: "15/04/2020"
bibliography: references.bib
link-citations: true
output:
  html_document:
    toc: true
    number_sections: true
    toc_float: true
    includes:
      before_body: doc_prefix.tex
  # pdf_document:
  #   toc: true
  #   number_sections: true
  #   includes:
  #     before_body: doc_prefix.tex
# knit: (function(inputFile, encoding) {
#   rmarkdown::render(inputFile, encoding = encoding,
#   output_dir = "output", output_format = "all") })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

if (!require(igraph)) {
    install.packages("igraph", repos="http://cran.uk.r-project.org")
}
```

# (Social) Network Data

Today we're going to demonstrate simple ways of loading network data, visualisation, analysing structure, and showing how this can help answer research questions. 

So a recurring point I'll make today is that there are lots of systems that can be represented as a network. Perhaps you're interested in **social** networks like twitter [@murthySociologicalUnderstandingSocial2012], but there are other types of networks that could be of interest [@teroRulesBiologicallyInspired2010]:

<iframe width="560" height="315" src="http://www.youtube.com/embed/GwKuFREOgmo?rel=0" frameborder="0" allowfullscreen></iframe>

## What is a Network?

A network is a way of representing how things are connected (or not). They can be social (who tweets to who), economic (which companies employ which people), engineering (which parts were used in each product) etc. The representing of these connetions is a network--also call a [graph](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)) in mathematics, (confusing eh?)--and in the social sciences it's a tool, often applied to help quantiatively (and sometimes qualitatively) answer research questions [@heathChasingShadowsDefining2009]. 

## Installing `R` and `igraph`

We're going to focus on the `igraph` `R` package today. There are [*many* other options](#na-packages) but `igraph` is a fairly comprehensive package for getting started. If you're looking to go beyond what we cover today, I recommend looking through the `igraph` documentation for your particular interests before trying the other packages, and feel free to email me [griffith.rees@sheffield.ac.uk](mailto:griffith.rees@sheffield.ac.uk) if you've got questions. Please ask *detailed* questions, demonstrating what you've trying to do and what you've tried so far so I can efficiently reply.

<!--Survey: Who's used R before?-->

<!--Survey: Who has a working R install?-->

<!--Survey: Who has a working igraph install? Let's just make sure that works for everyone.-->

For those that have got `igraph` installed feel free to continue further down this handout to play around with the data.

Everyone else: please download `RStudio` from <https://rstudio.com/products/rstudio/download/#download>.

It should fit your operating system automatically (Windows, Linux or Mac). If you're not seeing an option (possibly old versions of Windows, macOS, or unusual Linux distributions) message me. ^[Even if you're in a broader *nix category there are [options...](https://www.freshports.org/devel/RStudio/)]

<!--Survey: Finished installing R-->
Please fill in the survey when you're done or post messages if you're having issues.

Now let's install <https://igraph.org/r/>

```{r, eval=FALSE}
install.packages("igraph")
```

and then load it in your `R` session.

```{r, eval=FALSE}
library(igraph)
```

<!--Survey of people having completed this.-->

## Test loading `igraph` data

We're going to jump into visualisation with `igraph` as a test of the install and a demonstration of visualisation options. Then we'll break it down into what's going on underneath but again, feel free to mess around with what's loaded as we continue on.

We begin by loading node and edge data from [Dr Evelina Gabašová's](Dr Evelina Gabašová's) excellent dataset on [which characters appeared together in scenes of star wars films](http://evelinag.com/blog/2015/12-15-star-wars-social-network/). Shamlessly borrowing from an NYU [short course](https://github.com/pablobarbera/data-science-workshop/tree/master/sna) created by [Dr Pablo Barberá's](http://pablobarbera.com/) we focus on Episode IV - *A New Hope*.

You can have a look at my github repository for this course: <https://github.com/griff-rees/network-analysis-course> and download the repository. That includes the code for this handout and the data we're playing around with today.

Once you've downloaded unzipped and have a look in the data folder to make sure there are 4 csv files, including `star-wars-network-edges.csv`  and `star-wars-network-nodes.csv` The originals can be found at <https://github.com/pablobarbera/data-science-workshop/tree/master/sna/data>.

<!--
Please download these datafiles:

* <https://github.com/pablobarbera/data-science-workshop/raw/master/sna/data/star-wars-network-edges.csv>
* <https://github.com/pablobarbera/data-science-workshop/raw/master/sna/data/star-wars-network-nodes.csv>
  -->

### Load Node/Edge CSVs {#load-csvs}

<!--In this dataset, nodes are characters in the film and edges are the number of scenes they appear in together.-->

First load the csv of nodes and have it print out the list of records.
```{r}
nodes <- read.csv("data/star-wars-network-nodes.csv")
nodes
```
You should see two columns: list of character names from the film alongside a list of id numbers. We'll look at this in detail later.

* name (character names)
* id (integer)


Next load a list of edges:
```{r}
edges <- read.csv("data/star-wars-network-edges.csv")
edges
```

Again we'll go into this in further detail but for now it's just good to know everyone's got these up and working. You should see three columns:

* source (a character's name)
* target (another character's name)
* weight (an integer for the nuber of scenes they share)

There are many ways of storing network information, and we'll look at other options later. For now: note the nodes are the names of characters and the edges are pairs of characters followed by the number of scenes they share in the film.

### Creating a network

```{r}
g <- graph_from_data_frame(d=edges, vertices=nodes, directed=FALSE)
```

We'll look at how this works in detail in the next section, but note here that we load the `data.frame` of edges into the `d` parameter and the `data.frame` of nodes (in this characters) as vertices (another name for nodes in network analysis). We're setting `directed=FALSE` for simplicity (more on this later).

### Visualising a network

There are lots of ways to visualise networks. In part as a test of setup, we're jumping in to demonstrate how visualisation works and show make everything's installed correctly and the data is loading correctly as well.

```{r}
plot(g)
```

Mostly illegible eh? You're plot will have a different layout but as long as it looks similar we should be ready to go.

<!--Survey of this working for people.-->

Even with this rough layout we can, however, answer a research question:

Which character shares the *least* number of scenes with any other?

<center>

![A: R2-D2](img/r2-d2.jpg){width=15%} ![B: Gold Five](img/gold_five.jpg){width=15%} ![C: Leia](img/princess_leia.jpeg){width=15%} ![D: Jabba](img/jabba.png){width=15%} ![E: Greedo](img/greedo.jpg){width=15%}
<!--Survey of character who shares the least number of scenes between R2-D2, GREEDO, JABBA, Leia and GOLD FIVE.-->

</center>

Sneak preview of what's to come:

```{r, fig.width=12, fig.height=7, echo=FALSE}
# Prepare colour attributes
h <- g
dark_side <- c("DARTH VADER", "MOTTI", "TARKIN")
light_side <- c("R2-D2", "CHEWBACCA", "C-3PO", "LUKE", "CAMIE", "BIGGS",
                "LEIA", "BERU", "OWEN", "OBI-WAN", "HAN", "DODONNA",
                "GOLD LEADER", "WEDGE", "RED LEADER", "RED TEN", "GOLD FIVE")
neutral <- c("GREEDO", "JABBA")

# Add the color attribute to the network nodes
V(h)$color <- NA
V(h)$color[V(h)$name %in% dark_side] <- "red"
V(h)$color[V(h)$name %in% light_side] <- "gold"
V(h)$color[V(h)$name %in% neutral] <- "green"

plot(h, layout=layout_with_fr, main="Force-directed")
legend(x=.75, y=.75, legend=c("Dark side", "Light side", "Neutral"), 
       pch=21, pt.bg=c("red", "gold", "green"), pt.cex=2, bty="n")
```

# Networks (aka Graphs)

Now that we've got the basic package and a dataset up let's dive into the details of what's going on here. The goal is to give you enough of a foundation on network analysis to see how it can help answer research questions. It's also work mentioned that in mathematics networks are often called graphs, and fit under the ubrella term [graph theory](https://en.wikipedia.org/wiki/Graph_theory) hence the package name `igraph`. I'll use the terms *graph* and *network* interchangeably, while a visualisation of a network I'll try to call a plot (apologies in advance if I call a visualisation a graph!).

The basic components of networks/graphs are *nodes* and *edges*.

## Nodes

Each of the characters is a *node*, also know as a *vertex*. This is analogous to records in classic datasets like people or firms, which can include characteristics such as age or income. Nodes can have different characteristics too--usually called node attributes--and these can help in analysing and understanding the network.

### Node Attributes

Let's take a deeper look at the data we used to create the plot above:

```{r, eval=FALSE}
nodes
```

As mentioned in a [previous section](#load-CSVs) there are two components of data for each of these nodes:

* name (character names)
* id (integer)

To see how that shows up when loaded into an `igraph` network use the `V` (vertices, synonymous with nodes) function:

```{r}
V(g)
```

This lists the vertices/nodes, the id it holds in memory and how many there are. The `name` attribute is particularly helpful in graph visualisation as it shows up automatically with `igraph` plots. If you've not used `R` before, here's a useful way to look at parts of data (usually columns in a table) using the `$` symbol after the variable name, followed by the column name (like in the `nodes` variable) or the attribute name (like in the `g` network variable).

```{r, eval=FALSE}
nodes$name
V(g)$name
```

We also get a list of all attributes with

```{r}
vertex_attr(g)
```

### Adding Attributes

Let's add another attribute. Following the classic notion of the force in start wars we can add data indicating which side of the *force* characters are associated with (or othe if neighther). First we create vectors of names using the `c` (combine) function to get a vector of strings (names of nodes in this case).

```{r}
# Create 
dark_side <- c("DARTH VADER", "MOTTI", "TARKIN")
light_side <- c("R2-D2", "CHEWBACCA", "C-3PO", "LUKE", "CAMIE", "BIGGS",
                "LEIA", "BERU", "OWEN", "OBI-WAN", "HAN", "DODONNA",
                "GOLD LEADER", "WEDGE", "RED LEADER", "RED TEN", "GOLD FIVE")
neutral <- c("GREEDO", "JABBA")
```
Now we can add colours to the `nodes` based on the vectors of names we just created. `R` has a set of [colour names that can be used in plots](http://www.guianaplants.stir.ac.uk/seminar/materials/colorPaletteCheatsheet.pdf), feel free to pick your own. By storing one of these colour names in the new `color` attribute, we can have that directly show up in the visualisation. Note the spelling of `color`: if you add to a `colour` coloumn the data is stored but won't automatically affect the plot.

To add the color attribute, first create the column with an `NA` (refers to 'not available') value

```{r}
# Add the color attribute to the network nodes
V(g)$color <- NA  # Initialse the new 'color' attribute as NA for all nodes
```

then fill it up using the categories saved above. If you also run `V(h)$color` in between adding these you'll see the how the `$color` column gets populated

```{r}
V(g)$color[V(g)$name %in% dark_side] <- "red" # set the dark side color name to red
V(g)$color
```

To break this down: the `%in%` operation tests if data in one column---in this case the `$name` variable which is to the *left* of `%in%`---matches with (*is in*) the options on the *right* of the `%in%`. Where it does match it returns `TRUE`, and elsewhere it returns `FALSE`.

```{r}
V(g)$color[V(g)$name %in% light_side] <- "gold" # set the light side color name to gold
V(g)$color[V(g)$name %in% neutral] <- "green" # set the color of neutral characters to green
V(g)$color
```

In this case that means the colour value intended gets saved in places where they match the dark, light and neural sides. It's complicated to explain but extremely useful.

### Subgraphs

These attributes can help us look at *subgraphs*: portions of the graph such as just the `dark_side`:

```{r}
dark_side_graph <- induced_subgraph(g, dark_side) # Using the dark_side variable from above
V(dark_side_graph)
```

This raises an important point: so many aspects of the world can be thought of as a network, and just as populations are sampled to make summary claims---such as income distribution or age---we similarly often sample from networks to analyse them, and need to be aware that often there are portions of networks we cannot observe. Those sections may be very important, and in failing to observe them we can end up with very different structures and very different results.

In the classic sense of probability theory the [law of large numbers](https://en.wikipedia.org/wiki/Law_of_large_numbers) suggests that often 1000 trials of an experiment, or random samples from a population (often needing weighting to be representative), can lead to representative results for the whole population. This can unfortunately be very difficult to manage in the case of networks [@browneSnowballSamplingUsing2005].

<!-- Mention episode 1...?-->

### Visualising

It's worth acknowledging that we're focusing on specific attributes that help with visualisation. I got frustrated perparing some of these slides because I tried doing something *like* this but with a variation in spelling...

<!--Survey on confusion between British and American spelling-->
<!--Survey on British and American meaning of biscuit-->

```{r}
# load the data to a new variable (f) in the same way we loaded for g prior to adding colour
f <- graph_from_data_frame(d=edges, vertices=nodes, directed=FALSE)

# Add a colour attribute which using the British rather than American spelling...
V(f)$colour <- NA  # Initialse the new 'colour' attribute as NA for all nodes
V(f)$colour[V(f)$name %in% dark_side] <- "red" # set the dark side colour name to red
V(f)$colour[V(f)$name %in% light_side] <- "gold" # set the light side colour name to gold
V(f)$colour[V(f)$name %in% neutral] <- "green" # set the colour of neutral characters to green
plot(f)
```

Notice no difference in colour. Now compare that with 

```{r}
plot(g)
```

This should illustrate two things: 

* You can add lots of attributes to nodes in a way similar to adding a column of data to a normal `data.frame` like the `nodes` variable
* Some attributes can have a special role in particular network packages, such as `color` in `igraph`

Similarly: you can visualise specific sections of a graph, and that can be helpful in providing better detail/easier to read. Returning to the `dark_side_graph` subsample 

```{r}
plot(dark_side_graph)
```

This is a lot easier to read and can, as a way of zooming in give us a clearer picture of some aspects of the structure. This becomes more crucial with much larger network datasets. It's already difficult to read the names of characters in these plots. Let's compare it with the rest of other side of the force:

```{r}
light_side_graph <- induced_subgraph(g, light_side) # Using the light_side variable
plot(light_side_graph)
```
without the rest of the network around it but by itself and without the wider context it can be misleading. 
we can but it's often worth presenting it alongside the larger network it's subsampled from

Like many other quantitative methodologies there are many other types of attributes that can apply to nodes such as

* Numerical (age, body mass index, income)
* Boolean (yes/no, sex, citizenship <!-- mention I wasn't born with British citizenship-->, neutral)
* Categorical (ethnicity, class, nationality, sector, color as combination of side of the force or neutral)
* Spatial (geographic position, location in hospitals)

We'll return to the applicablity of these later but generally: most variables that can be used in classic statistical analysis can be applied in network analysis. It might be hard... but that data can generally be useful. 

To close: *be wary of sampling issues in network analysis!*
<!-- Ask for general feelings/survey for break -->

## Edges

Edges, also called links and ties, are the connections in networks/graphs. They can be friendship, kinship, contracts, following, liking, debt, etc. Our conversation right now is via a digital network, but if we were in the lab we'd originally planned to use there would be conversation face to face, just with a lot more physical movement and scribbling on a white board.

### Edge Data

To get started let's look at the second data file we loaded in the beginning

```{r}
head(edges)
```

The `head` and `tail` functions are very handy ways to peak at datasets, especially very large ones. They return 6 records from the start or end of `data.frame` respectively.

`edges` has three variables, the first two of which specify edges and the last is an attribute. We'll take these in turn

#### Directed or Undirected

Edges can be categorised as directed or undericted. So far, we've been working with an undirected graph, and that's why we include the `directed=FALSE` parameter in creating `g`: `g <- graph_from_data_frame(d=edges, vertices=nodes, directed=FALSE)`.

But it's no accident that the first two column names of the edges file are `source` and `target`. Different network packages follow different conventions (see the [appendix](#na-packages) for other packages) but directional information can be very important in networks. Someone can like someone else's tweet, just as a company can offer a contract to another or a paper can cite another paper. It's important in these cases to specify where the direction of the connection comes from, and some of the first social network analysis research (then called sociograms [@festingerWhoShallSurvive1954]) use directional infromation:

<center>

![Sociogram](img/sociogram.png)

</center>

In this study, people were individually asked to name friends at school. This diagram of friendship in a 4th grade (US term for UK year 5) class in the 1930s is a famous demonstration of a case where friendship is highly correlated with gender. If you look closesly (try `ctrl/cmd +` to zoom in) you'll see arrows pointing at circles such as from `EL` to `SH` while in a few, like the connection between `BR` and `MC` no arrows.

This means that `EL` named `SH` as a friend but `SH` didn't reciprocate (also name `EL` as a friend), while `BR` and `MC` both named each other as friends.

Here's a newer digram of the same network which is a bit easier to read from <http://www.martingrandjean.ch/social-network-analysis-visualization-morenos-sociograms-revisited/>:

<center>

![Directed Network](img/sociogram_network.png)

</center>

With the additional information of the shapes in the first digram which map to colours in the second, this is a way of demonstrating the separation of social groups by gender, but possibly how those groups are very *weakly* tied together. Weakness in as much as only one connection is named across gender and it is not reciprocated. There are ways of quantifying how different groups are connected in networks which is outside the scope of the session today, but there is lots of research on this in both social network analysis and many other types of network analysis [@leskovecEmpiricalComparisonAlgorithms2010]. 

To summarise: undirected networks have two basic states between nodes

**Undirected Networks**

* Connected (a is linked to b) formalised as $$a \ue b$$
* Unconnected (a is not linked to b) formalised as $$a \ne b$$

while directed networks have 3 basic states between nodes

**Directed Networks**

* Unidirectional (connection from a to b) formalised as $$a \de b$$
* Bidirectional (connections from a to b and b to a) formalised as $$ a \leftrightarrow b $$
* Unconnected (a is not linked to b) formalised as above $$a \ne b$$

And returning to the way we constructed `g` originally:
g
```{r}
g <- graph_from_data_frame(d=edges, vertices=nodes, directed=FALSE)
```
we can also construct that network as directed by leaving out `directed=FALSE` because the default value is `directed=TRUE` 
```{r}
d <- graph_from_data_frame(d=edges, vertices=nodes, directed=TRUE)
plot(d)
```

```{r}
d <- graph_from_data_frame(d=edges, vertices=nodes)
plot(d)
```

#### Edge Attributes

Just like nodes, edges can have attributes. The directionality in the previous section is an example of information associated with a tie, and the presence or absence of one. One of the most common examples of tie attributes is included in the star wars dataset, and is usually described as a *weighted tie*. This is the third column in `edges` labeled `weight`

```{r}
head(edges)
```

This is the number of scenes that both characters share in the film. If combined with the `source` and `target` information then it's a means of weighting directed ties/edges.

With all this in mind, we can look at the original star wars network for a glimpse of what's included in the whole structure:

```{r}
g
```

It's a bit technical but what it's showing is a summary of the network object:

* `U` means undirected  
* `N` means named graph (hence the names attribute)
* `W` means weighted graph  (hence the weight attribute)
* `22` is the number of nodes  
* `60` is the number of edges  
* `name (v/c)` means _name_ is a node attribute and it's a character  
* `weight (e/n)` means _weight_ is an edge attribute and it's numeric  

The rows are indicating connections between nodes so record `[1]` is between `R2-D2` and `C-3PO`.

Similar to the vertices `V()` function there is an edge function `E()` which prints the connections section from the summary of `g` just described.

```{r}
E(g)
```

And again in similarity to nodes, edge attributes are accessed by `$`:

```{r}
E(g)$weight
```

and the list of attributes is printed by the `edge_attr` function

```{r}
edge_attr(g)
```

I realise this is going very quickly but the point is to demonstrate how similar accessing edge attribution information is to accessing node attributes. 

With this demonstrated, we can now try adding another edge attribute. This is trickier than adding node attributes because there are so many, but building on the method we took before:

```{r}
E(g)$color <- "blue"
E(g)$color[E(g)$weight >= 5] <- "red"
```
This is a very simple case where we're colouring edges based on the weight, once again using the standard colour names that come with `R`. We've set the colour criteria to be for edges of greater weight than five (of which there are very few).

One again using the `edge_attr` function we can see what's been added:

```{r}
edge_attr(g)
```

And similar to node attributes, color has the extra significance of automatically being added to plots (though as this is few edges it might not show up obviously on your screen).

```{f}
plot(g)
```

Hope it's clear on some screens. We've obviously got issues with positioning which is to come. We're very close to finishing the edge section. We've got one more part to cover then on to the details of visualisation.

But before we do, once again we can use this visualisation (and the weight attribute to answer a question): which pair of characters share the most scenes in star wars IV?

#### Adjacency Matrix

So far the edges have all been via lists of pairs of node names, but other ways of representing edges is via a matrix, and that features a lot in other network packages. I'm just going to briefly show you that now

```{r}
g[]
```

For those of you interested in the details, the matrix is symmetrical if undirected and potentially asymetrical if directed. Each row and column are lists of connections between one node and all the others (including itself, which is the diagonal down the middle). I'm going to leave that there for today but just to give you some idea of where that comes from and what that means if you see a package asking for an ajacency matrix.

Notice: there aren't any cases of links to oneself (which wouldn't make sense in a film... except for maybe a sci-fi time travel one) but in other cases that can be clearer, such as emailing yourself (something I do all the time as reminders).

## Visualisation

Finally down to visualisation! We've obviously spent almost all this time on constructing the graph and understanding the data that composes it. But what's really annoying throughout (and generally a very hard problem, for which there are many packages) is a good arrangement of nodes. There's lots of work on this in general but to just get us up to the target we're going to dive into the `plot` function and the `layout` parameter

```{r, fig.width=12, fig.height=7}
par(mfrow=c(2, 3), mar=c(0,0,1,0))
plot(g, layout=layout_randomly, main="Random")
plot(g, layout=layout_in_circle, main="Circle")
plot(g, layout=layout_as_star, main="Star")
plot(g, layout=layout_as_tree, main="Tree")
plot(g, layout=layout_on_grid, main="Grid")
plot(g, layout=layout_with_fr, main="Force-directed")
```

These are some of the layout options to choose from. The `layout_with_fr` is a favorite of many, so that's what I used at the start. So to reproduce what I suggested:

```{r}
plot(g, layout=layout_with_fr)
legend(x=.75, y=.75, legend=c("Dark side", "Light side", "Neutral"), 
       pch=21, pt.bg=c("red", "gold", "green"), pt.cex=2, bty="n")
```

# What else?

## There's lots

- Negative ties (few studies but a recent [*Social Networks* special issue](https://www.sciencedirect.com/journal/social-networks/vol/60))
- [Erdős–Bacon number](https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Bacon_number)

## Useful links

* Most of this comes from/is inspired by Katherine Ognyanova's
  + [**Brilliant** visualisation guide](http://www.kateto.net/wp-content/uploads/2019/06/Sunbelt%202019%20R%20Network%20Visualization%20Workshop.pdf) 
  + Excellent github repo <https://github.com/kateto/R-Network-Visualization-Workshop>
* A bunch of useful links to papers/software etc. <https://github.com/briatte/awesome-network-analysis>
  
# Thanks

<!--## Another network time series...
![Network dynamics of creativity](collab_canvas.mov){ width=60% } -->
# Appendices

## Network Analysis Packages {#na-packages}

* R
    + [iGraph](https://igraph.org/r/) built on a C++ library, easier to get started and pre-dates ggplot so provides it's own visualisation options
    + [statnet](http://statnet.org/) focused particularly on [exponential random graphs (ERG) models](https://en.wikipedia.org/wiki/Exponential_random_graph_models), maintained by [Prof Carter T. Butts](https://scholar.google.co.uk/citations?user=-VGAs1cAAAAJ&hl=en)
    + [ggraph](https://ggraph.data-imaginist.com/) network visualisation in a way similar to [ggplot](https://ggplot2.tidyverse.org/reference/ggplot.html), maintained by [Thomas D Pedersen](https://www.data-imaginist.com/)
    + [Rsiena](https://www.stats.ox.ac.uk/~snijders/siena/) Actor-oriented logitudinal models (ERG), created by [Tom Snijders](https://cran.r-project.org/web/packages/RSiena/index.html)
* Python (my language of choice)
    + [networkx](https://networkx.github.io/) very old, not very fast but very flexible (my package of choice for ideas)
    + [igraph](https://igraph.org/python/) Effectively the same as the R package (both use the same underlying C++ library)
    + [graph-tool](https://graph-tool.skewed.de/) Much newer, very speed efficient (also C++ underneath)
* Windows
    + [UCINET](https://sites.google.com/site/ucinetsoftware/home) windows, developed and maintaied by (people including head of group at Manchester)

## References
