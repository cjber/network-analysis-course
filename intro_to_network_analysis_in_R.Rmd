---
title: "Introduction to (Social) Network Analysis in R"
author: "Dr Griffith Rees"
date: "15/04/2020"
bibliography: references.bib
link-citations: true
output:
  html_document:
    toc: true
    number_sections: true
    toc_float: true
    includes:
      before_body: doc_prefix.tex
  # pdf_document:
  #   toc: true
  #   number_sections: true
  #   includes:
  #     before_body: doc_prefix.tex
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding,
  output_dir = "output", output_format = "all") })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

if (!require(igraph)) {
    install.packages("igraph", repos="http://cran.uk.r-project.org")
}
```

# (Social) Network Data

Today we're going to demonstrate simple ways of loading network data, visualisation, analysing structure, and showing how this can help answer research questions. 

So a recurring point I'll make today is that there are lots of systems that can be represented as a network. Perhaps you're interested in **social** networks like twitter [@murthySociologicalUnderstandingSocial2012], but there are other types of networks that could be of interest [@teroRulesBiologicallyInspired2010]:

<iframe width="560" height="315" src="http://www.youtube.com/embed/GwKuFREOgmo?rel=0" frameborder="0" allowfullscreen></iframe>

## What is a Network?

A network is a way of representing how things are connected (or not). They can be social (who tweets to who), economic (which companies employ which people), engineering (which parts were used in each product) etc. The representing of these connetions is a network--also call a [graph](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)) in mathematics, (confusing eh?)--and in the social sciences it's a tool, often applied to help quantiatively (and sometimes qualitatively) answer research questions [@heathChasingShadowsDefining2009]. 

## Installing `R` and `igraph`

We're going to focus on the `igraph` `R` package today. There are [*many* other options](#na-packages) but `igraph` is a fairly comprehensive package for getting started. If you're looking to go beyond what we cover today, I recommend looking through the `igraph` documentation for your particular interests before trying the other packages, and feel free to email me [griffith.rees@sheffield.ac.uk](mailto:griffith.rees@sheffield.ac.uk) if you've got questions. Please ask *detailed* questions, demonstrating what you've trying to do and what you've tried so far so I can efficiently reply.

<!--Survey: Who's used R before?-->

<!--Survey: Who has a working R install?-->

<!--Survey: Who has a working igraph install? Let's just make sure that works for everyone.-->

For those that have got `igraph` installed feel free to continue further down this handout to play around with the data.

Everyone else: please download `RStudio` from <https://rstudio.com/products/rstudio/download/#download>.

It should fit your operating system automatically (Windows, Linux or Mac). If you're not seeing an option (possibly old versions of Windows, macOS, or unusual Linux distributions) message me. <!--^[Even if you're in a broader *nix category there are [options...](https://www.freshports.org/devel/RStudio/)]-->

<!--Survey: Finished installing R-->
Please fill in the survey when you're done or post messages if you're having issues.

Now let's install <https://igraph.org/r/>

```{r, eval=FALSE}
install.packages("igraph")
```

and then load it in your `R` session.

```{r, eval=FALSE}
library(igraph)
```

<!--Survey of people having completed this.-->

## Test loading `igraph` data

We're going to jump into visualisation with `igraph` as a test of the install and a demonstration of visualisation options. Then we'll break it down into what's going on underneath but again, feel free to mess around with what's loaded as we continue on.

We begin by loading node and edge data from [Dr Evelina Gabašová's](Dr Evelina Gabašová's) excellent dataset on [which characters appeared together in scenes of star wars films](http://evelinag.com/blog/2015/12-15-star-wars-social-network/). Shamlessly borrowing from an NYU [short course](https://github.com/pablobarbera/data-science-workshop/tree/master/sna) created by [Dr Pablo Barberá's](http://pablobarbera.com/) we focus on Episode IV - *A New Hope*.

You can have a look at my github repository for this course: <https://github.com/griff-rees/network-analysis-course> and download the repository. That includes the code for this handout and the data we're playing around with today.

Once you've downloaded unzipped and have a look in the data folder to make sure there are 4 csv files, including `star-wars-network-edges.csv`  and `star-wars-network-nodes.csv` The originals can be found at <https://github.com/pablobarbera/data-science-workshop/tree/master/sna/data>.

<!--
Please download these datafiles:

* <https://github.com/pablobarbera/data-science-workshop/raw/master/sna/data/star-wars-network-edges.csv>
* <https://github.com/pablobarbera/data-science-workshop/raw/master/sna/data/star-wars-network-nodes.csv>
  -->

### Load Node/Edge CSVs {#load-csvs}

<!--In this dataset, nodes are characters in the film and edges are the number of scenes they appear in together.-->

First load the csv of nodes and have it print out the list of records.
```{r}
nodes <- read.csv("data/star-wars-network-nodes.csv")
nodes
```
You should see two columns: list of character names from the film alongside a list of id numbers. We'll look at this in detail later.

* name (character names)
* id (integer)


Next load a list of edges:
```{r}
edges <- read.csv("data/star-wars-network-edges.csv")
edges
```

Again we'll go into this in further detail but for now it's just good to know everyone's got these up and working. You should see three columns:

* source (a character's name)
* target (another character's name)
* weight (an integer for the nuber of scenes they share)

There are many ways of storing network information, and we'll look at other options later. For now: note the nodes are the names of characters and the edges are pairs of characters followed by the number of scenes they share in the film.

### Creating a network

```{r}
g <- graph_from_data_frame(d=edges, vertices=nodes, directed=FALSE)
```

We'll look at how this works in detail in the next section, but note here that we load the `data.frame` of edges into the `d` parameter and the `data.frame` of nodes (in this characters) as vertices (another name for nodes in network analysis). We're setting `directed=FALSE` for simplicity (more on this later).

### Visualising a network

There are lots of ways to visualise networks. In part as a test of setup, we're jumping in to demonstrate how visualisation works and show make everything's installed correctly and the data is loading correctly as well.

```{r}
plot(g)
```

Mostly illegible eh? You're plot will have a different layout but as long as it looks similar we should be ready to go.

<!--Survey of this working for people.-->

Even with this rough layout we can, however, answer a research question:

Which character shares the *least* number of scenes with any other?

![A: R2-D2](img/r2-d2.jpg){width=20px} ![B: Gold Five](img/gold_five.jpg){width=30px}
<!--Survey of character who shares the least number of scenes between R2-D2, GREEDO, JABBA, Leia and GOLD FIVE.-->

Sneak preview of what's to come:

```{r, fig.width=12, fig.height=7, echo=FALSE}
# Prepare colour attributes
h <- g
dark_side <- c("DARTH VADER", "MOTTI", "TARKIN")
light_side <- c("R2-D2", "CHEWBACCA", "C-3PO", "LUKE", "CAMIE", "BIGGS",
                "LEIA", "BERU", "OWEN", "OBI-WAN", "HAN", "DODONNA",
                "GOLD LEADER", "WEDGE", "RED LEADER", "RED TEN", "GOLD FIVE")
neutral <- c("GREEDO", "JABBA")

# Add the color attribute to the network nodes
V(h)$color <- NA
V(h)$color[V(h)$name %in% dark_side] <- "red"
V(h)$color[V(h)$name %in% light_side] <- "gold"
V(h)$color[V(h)$name %in% neutral] <- "green"

plot(h, layout=layout_with_fr, main="Force-directed")
legend(x=.75, y=.75, legend=c("Dark side", "Light side", "Neutral"), 
       pch=21, pt.bg=c("red", "gold", "green"), pt.cex=2, bty="n")
```

# Networks (aka Graphs)

Now that we've got the basic package and a dataset up let's dive into the details of what's going on here. The goal is to give you enough of a foundation on network analysis to see how it can help answer research questions. It's also work mentioned that in mathematics networks are often called graphs, and fit under the ubrella term [graph theory](https://en.wikipedia.org/wiki/Graph_theory) hence the package name `igraph`. I'll use the terms *graph* and *network* interchangeably, while a visualisation of a network I'll try to call a plot (apologies in advance if I call a visualisation a graph!).

The basic components of networks/graphs are *nodes* and *edges*.

## Nodes

Each of the characters is a *node*, also know as a *vertex*. This is analogous to records in classic datasets like people or firms, which can include characteristics such as age or income. Nodes can have different characteristics too--usually called node attributes--and these can help in analysing and understanding the network.

### Node Attributes

Let's take a deeper look at the data we used to create the plot above:

```{r, eval=FALSE}
nodes
```

As mentioned in a [previous section](#load-CSVs) there are two components of data for each of these nodes:

* name (character names)
* id (integer)

To see how that shows up when loaded into an `igraph` network use the `V` (vertices, synonymous with nodes) function:

```{r}
V(g)
```

This lists the vertices/nodes, the id it holds in memory and how many there are. The `name` attribute is particularly helpful in graph visualisation as it shows up automatically with `igraph` plots. If you've not used `R` before, here's a useful way to look at parts of data (usually columns in a table) using the `$` symbol after the variable name, followed by the column name (like in the `nodes` variable) or the attribute name (like in the `g` network variable).

```{r, eval=FALSE}
nodes$name
V(g)$name
```

We also get a list of all attributes with

```{r}
vertex_attr(g)
```

### Adding Attributes

Let's add another attribute. Following the classic notion of the force in start wars we can add data indicating which side of the *force* characters are associated with (or othe if neighther). First we create vectors of names using the `c` (combine) function to get a vector of strings (names of nodes in this case).

```{r}
# Create 
dark_side <- c("DARTH VADER", "MOTTI", "TARKIN")
light_side <- c("R2-D2", "CHEWBACCA", "C-3PO", "LUKE", "CAMIE", "BIGGS",
                "LEIA", "BERU", "OWEN", "OBI-WAN", "HAN", "DODONNA",
                "GOLD LEADER", "WEDGE", "RED LEADER", "RED TEN", "GOLD FIVE")
neutral <- c("GREEDO", "JABBA")
```
Now we can add colours to the `nodes` based on the vectors of names we just created. `R` has a set of [colour names that can be used in plots](http://www.guianaplants.stir.ac.uk/seminar/materials/colorPaletteCheatsheet.pdf), feel free to pick your own. By storing one of these colour names in the new `color` attribute, we can have that directly show up in the visualisation. Note the spelling of `color`: if you add to a `colour` coloumn the data is stored but won't automatically affect the plot.

To add the color attribute, first create the column with an `NA` (refers to 'not available') value

```{r}
# Add the color attribute to the network nodes
V(g)$color <- NA  # Initialse the new 'color' attribute as NA for all nodes
```

then fill it up using the categories saved above. If you also run `V(h)$color` in between adding these you'll see the how the `$color` column gets populated

```{r}
V(g)$color[V(g)$name %in% dark_side] <- "red" # set the dark side color name to red
V(g)$color
```

To break this down: the `%in%` operation tests if data in one column---in this case the `$name` variable which is to the *left* of `%in%`---matches with (*is in*) the options on the *right* of the `%in%`. Where it does match it returns `TRUE`, and elsewhere it returns `FALSE`.

```{r}
V(g)$color[V(g)$name %in% light_side] <- "gold" # set the light side color name to gold
V(g)$color[V(g)$name %in% neutral] <- "green" # set the color of neutral characters to green
V(g)$color
```

In this case that means the colour value intended gets saved in places where they match the dark, light and neural sides. It's complicated to explain but extremely useful.

### Subgraphs

These attributes can help us look at *subgraphs*: portions of the graph such as just the `dark_side`:

```{r}
dark_side_graph <- induced_subgraph(g, dark_side) # Using the dark_side variable from above
V(dark_side_graph)
```

This raises an important point: so many aspects of the world can be thought of as a network, and just as populations are sampled to make summary claims---such as income distribution or age---we similarly often sample from networks to analyse them, and need to be aware that often there are portions of networks we cannot observe. Those sections may be very important, and in failing to observe them we can end up with very different structures and very different results.

In the classic sense of probability theory the [law of large numbers](https://en.wikipedia.org/wiki/Law_of_large_numbers) suggests that often 1000 trials of an experiment, or random samples from a population (often needing weighting to be representative), can lead to representative results for the whole population. This can unfortunately be very difficult to manage in the case of networks [@browneSnowballSamplingUsing2005].

<!-- Mention episode 1...?-->

### Visualising

It's worth acknowledging that we're focusing on specific attributes that help with visualisation. I got frustrated perparing some of these slides because I tried doing something *like* this but with a variation in spelling...

<!--Survey on confusion between British and American spelling-->
<!--Survey on British and American meaning of biscuit-->

```{r}
# load the data to a new variable (f) in the same way we loaded for g prior to adding colour
f <- graph_from_data_frame(d=edges, vertices=nodes, directed=FALSE)

# Add a colour attribute which using the British rather than American spelling...
V(f)$colour <- NA  # Initialse the new 'colour' attribute as NA for all nodes
V(f)$colour[V(f)$name %in% dark_side] <- "red" # set the dark side colour name to red
V(f)$colour[V(f)$name %in% light_side] <- "gold" # set the light side colour name to gold
V(f)$colour[V(f)$name %in% neutral] <- "green" # set the colour of neutral characters to green
plot(f)
```

Notice no difference in colour. Now compare that with 

```{r}
plot(g)
```

This should illustrate two things: 

* You can add lots of attributes to nodes in a way similar to adding a column of data to a normal `data.frame` like the `nodes` variable
* Some attributes can have a special role in particular network packages, such as `color` in `igraph`

Similarly: you can visualise specific sections of a graph, and that can be helpful in providing better detail/easier to read but it's often worth presenting it alongside the larger network it's subsampled from

```{r}
plot(dark_side_graph)
```

Like many other quantitative methodologies there are many other types of attributes that can apply to nodes such as

* Numerical (age, body mass index, income)
* Categorical (ethnicity, class, nationality, sector, side of the force (or nutral))
* Geographic (coordinates)

We'll return to the applicablity of these later but generally: most variables that can be used in classic statistical analysis can be applied in network analysis. It might be hard... but that data can generally be useful. 

To close: *be wary of sampling issues in network analysis!*
<!-- Ask for general feelings/survey for break -->

## Edges

Edges, also called vertices, the connections in networks/graphs. They can be friendship, kinship, contracts, following, liking, debt, etc. Our conversation right now is via a digital network, but if we were in the lab we'd originally planned to use there it would still be face to face, just with a lot more physical movement and scribbling on a white board.




So: 
The first step is to read the list of edges and nodes in this network:

```{r}
edges <- read.csv("data/star-wars-network-edges.csv")
head(edges)
nodes <- read.csv("data/star-wars-network-nodes.csv")
head(nodes)
```
For example, we learn that C-3PO and R2-D2 appeared in 17 scenes together.

How do we convert these two datasets into a network object in R? There are multiple packages to work with networks, but the most popular is `igraph` because it's very flexible and easy to do, and in my experience it's much faster and scales well to very large networks. Other packages that you may want to explore are `sna` and `networks`. We'll see an example later in this class, because some network modeling packages are not compatible with `igraph`.

Now, how do we create the igraph object? We can use the `graph_from_data_frame` function, which takes two arguments: `d`, the `data.frame` with the edge list in the first two columns; and `vertices`, a `data.frame` with node data with the node label in the first column. (Note that igraph calls the nodes `vertices`, but it's exactly the same thing.)

```{r, message=FALSE}
g <- graph_from_data_frame(d=edges, vertices=nodes, directed=FALSE)
g
```

What does it mean?

* `U` means undirected  
* `N` means named graph  
* `W` means weighted graph  
* `22` is the number of nodes  
* `60` is the number of edges  
* `name (v/c)` means _name_ is a node attribute and it's a character  
* `weight (e/n)` means _weight_ is an edge attribute and it's numeric  

This is how you access specific elements within the igraph object:

```{r}
V(g) # nodes
V(g)$name # names of each node
vertex_attr(g) # all attributes of the nodes
E(g) # edges
E(g)$weight # weights for each edge
edge_attr(g) # all attributes of the edges
g[] # adjacency matrix
g[1,] # first row of adjacency matrix
```


## Basic undirected network
```{r undirected, echo=FALSE, message=FALSE, warning=FALSE, }
g1 <- graph( edges=c("A","B", "B","C", "C", "A"), directed=FALSE ) 
plot(g1, vertex.size=100, vertex.label.cex=5, edge.width=5)
```

- A, B and C are *nodes* or *vertices* (people, companies, countries etc.)
- Connections are often called *ties* or *edges* (friendship, communication, contracts, kinship etc.)
- Undirected
$$A \ue B;B \ue C; C \ue A$$

## Advantages

* A way of representing a system (social, economic, digital, biological etc.)
* Can help explore and model
    + Properties [@wassermanSocialNetworkAnalysis1994]
    + Visualisations [@kerrenMultivariateNetworkVisualization2014]
    + Dynamics [@saavedraAsymmetricDisassemblyRobustness2008]
    + Simulations [@bearmanChainsAffectionStructure2004]
    
## Risks

* Complexity and size of data
* Sampling issues: **not law of large numbers** [@browneSnowballSamplingUsing2005]
* Pleathora of options
* Causal claims [@vanderweeleSocialNetworksCausal2013]
    
# Nodes

## Category, Type & Attribute
```{r types, echo=FALSE, message=FALSE, warning=FALSE, }
V(g1)[0:1]$color <- "green"
plot(g1, vertex.shape=c("circle", "square", "circle"), vertex.size=c(100, 100, 160), vertex.label.cex=5, edge.width=5)
```

- Category or group (club membership, kinship etc.)
- Type (employee, firm, region etc.)
- Attribute (age, ethnicity, size etc.)

## Structure of Romantic and Sexual Relations

<!--Could add bipartite here-->
* <https://github.com/pablobarbera/data-science-workshop/raw/master/sna/data/congress-twitter-network-edges.csv>
* <https://github.com/pablobarbera/data-science-workshop/raw/master/sna/data/congress-twitter-network-nodes.csv>

# Edges

## Direction, Weight & Type
```{r directed, echo=FALSE, message=FALSE, warning=FALSE, }
edge.scale <- c(7, 28, 3, 3, 5) 
arrow.scale <- edge.scale/1.2
g1 <- graph( edges=c("A","B", "B","C", "C", "A", "A", "C", "B", "B"), 
             directed=TRUE ) 
E(g1)$color <- c("blue", "red", "blue", "blue", "blue")
plot(g1, vertex.size=100,
     vertex.label.cex=5,
     edge.width=edge.scale,
     edge.arrow.size=arrow.scale
     )
```

- Direction (transaction, contract, message sender vs reciever etc.)
- Weight (amount of transaction, length of contract, frequency of message etc.)
- Type (type of transaction, cateory, texts vs tweets etc.)
- $A \de B; B \de C; C \leftrightarrow A; B \de B$

## Too impressive to be true?

<iframe width="560" height="315" src="http://www.youtube.com/embed/8aEtyRD1j5U?rel=0" frameborder="0" allowfullscreen></iframe>

## That's what lots have said[^1]...

- *Homophily and Contagion Are Generically Confounded in Observational Social Network Studies* [@shaliziHomophilyContagionAre2011]
- *The “unfriending” problem: The consequences of homophily in friendship retention for causal estimates of social influence* [@noelUnfriendingProblemConsequences2011]
- *Is obesity contagious? Social networks vs. environmental factors in the obesity epidemic* [@cohen-coleObesityContagiousSocial2008]
- *The spread of obesity in a large social network over 32 years* [@merckenDynamicsAdolescentFriendship2010][^2]
- ... and a reply: Christakis & Fowler [-@christakisSocialContagionTheory2013]

[^1]: See <https://statmodeling.stat.columbia.edu/2011/06/10/christakis-fowl/> for a summary
[^2]: Full disclosure: one of my examiners was a co-author on one of these papers...

# Types of Nodes 

Two types of Nodes (aka Bimodal or Bipartite Networks)

So far we've looked at nodes which vary in attributes (like name) but not in terms of types. A lot of work has been done on networks with 

## How to enforce different types of nodes


# What else?

## There's lots

- Negative ties (few studies but a recent [*Social Networks* special issue](https://www.sciencedirect.com/journal/social-networks/vol/60))
- [Erdős–Bacon number](https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Bacon_number)

## Useful links

* Most of this comes from/is inspired by Katherine Ognyanova's
  + [**Brilliant** visualisation guide](http://www.kateto.net/wp-content/uploads/2019/06/Sunbelt%202019%20R%20Network%20Visualization%20Workshop.pdf) 
  + Excellent github repo <https://github.com/kateto/R-Network-Visualization-Workshop>
* A bunch of useful links to papers/software etc. <https://github.com/briatte/awesome-network-analysis>
  
# Thanks

<!--## Another network time series...
![Network dynamics of creativity](collab_canvas.mov){ width=60% } -->
# Appendices

## Network Analysis Packages {#na-packages}

* R
    + [iGraph](https://igraph.org/r/) built on a C++ library, easier to get started and pre-dates ggplot so provides it's own visualisation options
    + [statnet](http://statnet.org/) focused particularly on [exponential random graphs (ERG) models](https://en.wikipedia.org/wiki/Exponential_random_graph_models), maintained by [Prof Carter T. Butts](https://scholar.google.co.uk/citations?user=-VGAs1cAAAAJ&hl=en)
    + [ggraph](https://ggraph.data-imaginist.com/) network visualisation in a way similar to [ggplot](https://ggplot2.tidyverse.org/reference/ggplot.html), maintained by [Thomas D Pedersen](https://www.data-imaginist.com/)
    + [Rsiena](https://www.stats.ox.ac.uk/~snijders/siena/) Actor-oriented logitudinal models (ERG), created by [Tom Snijders](https://cran.r-project.org/web/packages/RSiena/index.html)
* Python (my language of choice)
    + [networkx](https://networkx.github.io/) very old, not very fast but very flexible (my package of choice for ideas)
    + [igraph](https://igraph.org/python/) Effectively the same as the R package (both use the same underlying C++ library)
    + [graph-tool](https://graph-tool.skewed.de/) Much newer, very speed efficient (also C++ underneath)
* Windows
    + [UCINET](https://sites.google.com/site/ucinetsoftware/home) windows, developed and maintaied by (people including head of group at Manchester)

## References
